// Package library provides library-specific code generation for Go projects.
package library

import (
	"fmt"
	"strings"

	"project-initiator/internal/domain"
)

// Manager handles library-specific code generation.
type Manager struct {
	data domain.Project
}

// NewManager creates a new library manager for the given project.
func NewManager(data domain.Project) *Manager {
	return &Manager{data: data}
}

// HasLibrary checks if a library is included.
func (m *Manager) HasLibrary(name string) bool {
	name = strings.ToLower(name)
	for _, lib := range m.data.Libraries {
		if strings.ToLower(lib) == name {
			return true
		}
	}
	return false
}

// GenerateReadme generates a README with library information.
func (m *Manager) GenerateReadme() string {
	lines := []string{
		"# " + m.data.Name,
		"",
		"Generated by project-initiator.",
		"",
		"Included libraries:",
	}
	if m.HasLibrary("gin") {
		lines = append(lines, "- Gin")
	}
	if m.HasLibrary("gorm") {
		lines = append(lines, "- Gorm")
	}
	if m.HasLibrary("sqlc") {
		lines = append(lines, "- Sqlc")
		lines = append(lines, "", "Run: `sqlc generate`")
	}
	lines = append(lines, "")
	return strings.Join(lines, "\n")
}

// GenerateGoMod generates a go.mod file with library dependencies.
func (m *Manager) GenerateGoMod(goVersion string) string {
	lines := []string{
		"module " + m.data.Module,
		"",
		"go " + goVersion,
		"",
		"require (",
	}
	if m.HasLibrary("gin") {
		lines = append(lines, "\tgithub.com/gin-gonic/gin v1.10.0")
	}
	if m.HasLibrary("gorm") {
		lines = append(lines, "\tgorm.io/driver/sqlite v1.5.7")
		lines = append(lines, "\tgorm.io/gorm v1.25.12")
	}
	lines = append(lines, ")")
	return strings.Join(lines, "\n") + "\n"
}

// GenerateMain generates the main.go file with library imports and setup.
func (m *Manager) GenerateMain(framework string) string {
	imports := []string{"\"fmt\""}
	if m.HasLibrary("gin") {
		imports = append(imports, fmt.Sprintf("\"%s/internal/http\"", m.data.Module))
	}
	if m.HasLibrary("gorm") {
		imports = append(imports, fmt.Sprintf("\"%s/internal/db\"", m.data.Module))
	}

	body := []string{}
	body = append(body, "func run() error {")
	body = append(body, "\tfmt.Println(\"starting\")")
	if m.HasLibrary("gorm") {
		body = append(body, "\tdbConn, err := db.Open()")
		body = append(body, "\tif err != nil {\n\t\treturn err\n\t}")
		body = append(body, "\tif err := db.AutoMigrate(dbConn); err != nil {\n\t\treturn err\n\t}")
	}
	if m.HasLibrary("sqlc") {
		body = append(body, "\t// Run: sqlc generate")
	}
	if m.HasLibrary("gin") {
		body = append(body, "\tserver := http.NewServer()")
		if m.HasLibrary("gorm") {
			body = append(body, "\t_ = dbConn")
		}
		body = append(body, "\treturn server.Run(\":3000\")")
	} else {
		body = append(body, "\treturn nil")
	}
	body = append(body, "}")

	mainBody := []string{
		"func main() {",
		"\tif err := run(); err != nil {",
		"\t\tfmt.Println(\"error:\", err)",
		"\t}",
		"}",
	}

	code := []string{"package main", "", "import ("}
	for _, imp := range imports {
		code = append(code, "\t"+imp)
	}
	code = append(code, ")", "", strings.Join(body, "\n"), "", strings.Join(mainBody, "\n"), "")

	return strings.Join(code, "\n")
}

// FileTemplates returns additional file templates for libraries.
func (m *Manager) FileTemplates() map[string]string {
	templates := make(map[string]string)

	if m.HasLibrary("gin") {
		templates["internal/http/server.go"] = goGinServer
		templates["internal/http/routes.go"] = fmt.Sprintf(goGinRoutesTemplate, m.data.Name)
	}
	if m.HasLibrary("gorm") {
		templates["internal/db/db.go"] = goGormDB
		templates["internal/db/models.go"] = goGormModels
	}
	if m.HasLibrary("sqlc") {
		templates["sqlc.yaml"] = goSqlcConfig
		templates["db/schema.sql"] = goSqlcSchema
		templates["db/query.sql"] = goSqlcQuery
		templates["internal/db/README.md"] = goSqlcReadme
	}

	return templates
}

// ReplacedFiles returns the set of files that should be replaced when using libraries.
func (m *Manager) ReplacedFiles(projectSlug string) map[string]bool {
	if !m.HasLibrary("gin") && !m.HasLibrary("gorm") && !m.HasLibrary("sqlc") {
		return nil
	}

	replaced := map[string]bool{
		"go.mod":    true,
		"README.md": true,
	}

	// Main file location depends on framework
	if strings.EqualFold(m.data.Framework, "cobra") {
		replaced[fmt.Sprintf("cmd/%s/main.go", projectSlug)] = true
	} else {
		replaced["main.go"] = true
	}

	return replaced
}

const goGinServer = `package http

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

func NewServer() *gin.Engine {
	router := gin.New()
	router.Use(gin.Recovery())

	RegisterRoutes(router)

	router.GET("/health", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"status": "ok"})
	})

	return router
}
`

const goGinRoutesTemplate = `package http

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

func RegisterRoutes(router *gin.Engine) {
	router.GET("/", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"message": "hello from %s"})
	})
}
`

const goGormDB = `package db

import (
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
)

func Open() (*gorm.DB, error) {
	return gorm.Open(sqlite.Open("app.db"), &gorm.Config{})
}
`

const goGormModels = `package db

import "gorm.io/gorm"

type User struct {
	ID   uint
	Name string
}

func AutoMigrate(db *gorm.DB) error {
	return db.AutoMigrate(&User{})
}
`

const goSqlcConfig = `version: "2"
sql:
  - engine: "sqlite"
    schema: "db/schema.sql"
    queries: "db/query.sql"
    gen:
      go:
        package: "db"
        out: "internal/db"
`

const goSqlcSchema = `CREATE TABLE users (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL
);
`

const goSqlcQuery = `-- name: ListUsers :many
SELECT id, name FROM users;

-- name: CreateUser :exec
INSERT INTO users (name) VALUES (?);
`

const goSqlcReadme = `# SQLC

Run ` + "`" + `sqlc generate` + "`" + ` to generate Go code into internal/db.
`
